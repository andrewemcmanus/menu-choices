# The program should then find a combination of dishes that has a total of exactly the target price.
# If there is no solution found, then the program should print that there is no combination of dishes that is equal to the target price.
# The program must run with different data files generated by us in the same format, so provide instructions on github.com on how to run the program from command line with command line parameters to read alternative input file.

# Reverse engineer: assemble all possible combinations?

prices = {
  "mixed fruit": 2.15,
  "french fries": 2.75,
  "side salad": 3.35,
  "hot wings": 3.55,
  "mozzarella sticks": 4.20,
  "sampler plate": 5.80
  }

class Solution(object):
   def combinationSum(self, menu, to_spend):
      result = []
      unique = {}
      menu = list(set(menu))
      self.solve(menu, to_spend, result, unique)
      # print(menu)
      return result
   def solve(self, menu, to_spend, result, unique, i = 0, current=[]):
      if to_spend == 0:
         temp = [i for i in current]
         # print(temp)
         temp1 = temp
         temp.sort()
         temp = tuple(temp)
         print(temp)
         if temp not in unique:
            unique[temp] = 1
            result.append(temp1)
         return
      if to_spend < 0:
         return
      for x in range(i, len(menu)):
         current.append(menu[x])
         self.solve(menu, to_spend - menu[x], result, unique, i, current)
         current.pop(len(current) - 1)
ob1 = Solution()
print(ob1.combinationSum([2.15, 2.75, 3.35, 3.55, 4.20, 5.80], 15.05))
